(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{143:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return d}));var a=n(1),o=n(9),i=(n(0),n(155)),r={id:"transition",title:"Transition Probability"},l={id:"transition",title:"Transition Probability",description:"## Definition",source:"@site/../modules/aruku-docs/target/mdoc/transition.md",permalink:"/aruku/docs/transition",editUrl:"https://github.com/pierrenodet/aruku/edit/master/../modules/aruku-docs/target/mdoc/transition.md",sidebar:"someSidebar",previous:{title:"Configuration",permalink:"/aruku/docs/configuration"},next:{title:"Provided Walks",permalink:"/aruku/docs/walks"}},s=[{value:"Definition",id:"definition",children:[]},{value:"Oblivious",id:"oblivious",children:[]},{value:"Static",id:"static",children:[]},{value:"Dynamic",id:"dynamic",children:[]}],c={rightToc:s};function d(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"definition"},"Definition"),Object(i.b)("p",null,"A transition probability is the probability of a random walker to jump to a node for the next step of his walk."),Object(i.b)("p",null,"It's made of three key components :"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Static Component : Reflects the edge component")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Dynamic Component : Reflects the state of the walker")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Extension Component : Reflects the termination of the walker"))),Object(i.b)("h2",{id:"oblivious"},"Oblivious"),Object(i.b)("p",null,"An oblivious walk contains only an extension component."),Object(i.b)("p",null,"It's the simplest random walk possible as it doesn't follow any kind of edge componenent or change during the walk."),Object(i.b)("p",null,"For example let's create a random walk that stop after ",Object(i.b)("inlineCode",{parentName:"p"},"walkLength")," steps :"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"import org.apache.spark.graphx.{ Edge, VertexId }\nimport aruku._\n\ncase object ObliviousWalk {\n\n  def transition(walkLength: Long) =\n    Transition.oblivious(\n      (walker: Walker[ObliviousWalk.type], _: VertexId) => \n        if (walker.step < walkLength) 1.0 else 0.0\n    )\n\n}\n")),Object(i.b)("h2",{id:"static"},"Static"),Object(i.b)("p",null,"An static walk contains only an extension component and a static componenent."),Object(i.b)("p",null,"It's a more realistic component as often seen a real world graph, the edge component matters to determine the strength of the link between two vertices."),Object(i.b)("p",null,"Let's add a static componenent to our previous oblivous walk :"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"import org.apache.spark.graphx.{ Edge, VertexId }\nimport aruku._\n\ncase object StaticWalk {\n\n  def transition(walkLength: Long) =\n    Transition.static(\n      (walker: Walker[StaticWalk.type], _: VertexId) => \n        if (walker.step < walkLength) 1.0 else 0.0,\n      (vid: VertexId, edge: Edge[Double]) => edge.attr\n    )\n\n}\n")),Object(i.b)("p",null,"Hey we made DeepWalk !"),Object(i.b)("h2",{id:"dynamic"},"Dynamic"),Object(i.b)("p",null,"An dynamic walk contains all three components, extension, static and dynamic."),Object(i.b)("p",null,"For more elaborate random walk, the walker is gonna decide to jump to the next node thanks to it's internal state."),Object(i.b)("p",null,"If we wanted to make node2vec, the transition probability would look like this :"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"import org.apache.spark.graphx.{ Edge, VertexId }\nimport aruku._\n\ncase class DynamicWalk(previous: VertexId)\n\nobject DynamicWalk {\n\n def transition(p: Double, q: Double, walkLength: Long) =\n\n    Transition.secondOrder(\n      (walker: Walker[DynamicWalk], _: VertexId) => \n        if (walker.step < walkLength) 1.0 else 0.0,\n      (vid: VertexId, edge: Edge[Double]) => edge.attr,\n      (walker: Walker[DynamicWalk], _: VertexId, edges: Array[Edge[Double]]) => \n        Some(edges.map(_.dstId)),\n      (\n        walker: Walker[DynamicWalk],\n        current: VertexId,\n        next: Edge[Double],\n        msg: Option[Array[VertexId]]\n      ) =>\n        msg match {\n          case Some(previousNeighbors) =>\n            if (previousNeighbors.contains(next)) {\n              1\n            } else if (next == walker.data.previous) {\n              1 / p\n            } else {\n              1 / q\n            }\n          case None => 1.0\n        },\n      (_: VertexId, _: Array[Edge[Double]]) => math.max(1 / p, math.max(1, 1 / q)),\n      (_: VertexId, _: Array[Edge[Double]]) => math.min(1 / p, math.min(1, 1 / q))\n    )\n\n}\n")),Object(i.b)("p",null,"As you can see, node2vec is a second order random walk, so the walker can actually carry a message with him for his next step. For node2vec the messages contains the neighbors of the previous vertice so we can compute correctly the dynamic component."))}d.isMDXComponent=!0}}]);